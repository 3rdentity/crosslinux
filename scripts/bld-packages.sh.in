#!@@CL_BASH@@


# This file is part of the crosslinux software.
# The license which this software falls under is GPLv2 as follows:
#
# Copyright (C) 2013-2013 Douglas Jerome <douglas@crosslinux.org>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA


# *****************************************************************************
#
# PROGRAM DESCRIPTION
#
#      This script builds the crosslinux target packages.
#
# CHANGE LOG
#
#      2013-06-22  drj  Adapted to crosslinux from the ttylinux build system.
#
# *****************************************************************************


# *************************************************************************** #
#                                                                             #
# F I L T E R E D   C O N S T A N T S                                         #
#                                                                             #
# *************************************************************************** #

cl_libdir="@@CL_LIBDIR@@"


# *************************************************************************** #
#                                                                             #
# F U N C T I O N S                                                           #
#                                                                             #
# *************************************************************************** #


# *****************************************************************************
# Make a file to list the package contents.
# *****************************************************************************

# Function Arguments:
#      $1 ... ASCII file that is the file list

package_list_make() {

# The file list is an ASCII file that is the list of files from which to make
# the binary package; it can have some scripting that interprets variables to
# enable the selection of package files, so the file list needs some special
# processing.  It is filtered, honoring any embedded scripting, and the actual
# list of binary package files is created as ${TARGET_VAR_DIR}/files

local cfgPkgFiles="$1"
local pathname=""

local -i lineNum=0
local -i nestings=0
local -i uselines=1
local -i oldUseLine=1
local -i retStat=0

CL_logcom "***** Making Package File List"

rm --force "${TARGET_VAR_DIR}/files"
>"${TARGET_VAR_DIR}/files"
while read; do
	lineNum=$((${lineNum}+1))
	if [[ "${REPLY}" =~ ^if\  ]]; then # ........ Interpret the 'if' lines.
		if [[ ${nestings} == 1 ]]; then
CL_logcom "E> Cannot nest scripting in pkg-cfg files-list file."
CL_logcom "=> line ${lineNum}: \"${REPLY}\""
			continue
		fi
		set ${REPLY}
		if [[ $# != 4 ]]; then
CL_logcom "E> IGNORING malformed script in pkg-cfg files-list file."
CL_logcom "=> line ${lineNum}: \"${REPLY}\""
			continue
		fi
		oldUseLine=${uselines}
		eval [[ "\$$2" $3 "$4" ]] && uselines=1 || uselines=0
		nestings=1
CL_logcom "if \$$2 $3 $4 # -- nestings=${nestings} uselines=${uselines}"
		continue
	fi
	if [[ "${REPLY}" =~ ^fi ]]; then # .......... Interpret the 'fi' lines.
		uselines=${oldUseLine}
		nestings=0
CL_logcom "fi # ------------- nestings=${nestings} uselines=${uselines}"
		continue
	fi
	if [[ "${REPLY}" =~ ^\ *# ]]; then # ..... Interpret the comment lines.
CL_logcom "Skipping ${REPLY}"
		continue
	fi
	if [[ ${uselines} == 1 ]]; then # ........... Interpret the used lines.
		eval "pathname=${REPLY}"
		echo ${pathname} >>"${TARGET_VAR_DIR}/files"
	fi
done <"${cfgPkgFiles}"

while read; do
	if [[ ! -e ${TARGET_SYSROOT_DIR}/${REPLY} ]]; then
		CL_logcom "ERROR ***** missing \"${REPLY}\""
		CL_logcom "=> in ${cfgPkgFiles}"
		retStat=1
	fi
done <"${TARGET_VAR_DIR}/files"

if [[ ${retStat} -eq 1 ]]; then
	echo -e "${TEXT_BRED}ERROR${TEXT_NORM}"         >&${CONSOLE_FD}
	echo    "E> Something wrong in ${cfgPkgFiles}." >&${CONSOLE_FD}
fi

return ${retStat}

}


# *****************************************************************************
# Build a package from source and install into the sysroot.
# *****************************************************************************

# Function Arguments:
#      $1 ... Package name, like "glibc-2.19".

package_xbuild() {

echo -n "g." >&${CONSOLE_FD}

# Check for the package build script.
#
if [[ ! -f "${CROSSLINUX_PKGCFG_DIR}/$1/bld.sh" ]]; then
	CL_logcom "ERROR ***** Cannot find build script."
	CL_logcom "=> ${CROSSLINUX_PKGCFG_DIR}/$1/bld.sh"
	echo -e "${TEXT_BRED}ERROR${TEXT_NORM}"            >&${CONSOLE_FD}
	echo    "E> Cannot find build script."             >&${CONSOLE_FD}
	echo    "   => ${CROSSLINUX_PKGCFG_DIR}/$1/bld.sh" >&${CONSOLE_FD}
	exit 1 # Bust out of sub-shell.
fi

# Get the crosslinux-specific rootfs, if any.
#
if [[ -f "${CROSSLINUX_PKGCFG_DIR}/$1/rootfs.tar.bz2" ]]; then
	cp "${CROSSLINUX_PKGCFG_DIR}/$1/rootfs.tar.bz2" .
	${cl_bzip2} --decompress --force "rootfs.tar.bz2"
	${cl_tar} --extract --file="rootfs.tar"
	rm --force "rootfs.tar"
fi

# ${CROSSLINUX_PKGCFG_DIR}/$1/bld.sh defines several variables and functions:
#
# Functions
#
#	pkg_patch	This function applies any patches or fix-ups to the
#			source package before building.
#			NOTE -- Patches are applied before package
#				configuration.
#
#	pkg_configure	This function configures the source package for
#			building.
#			NOTE -- Post-configuration patches might be applied.
#
#	pkg_make	This function builds the source package in place in the
#			${TARGET_BUILD_DIR}/packages/ directory
#
#	pkg_install	This function installs any built items into the build
#			root ${TARGET_SYSROOT_DIR}/ directory tree.
#
#	pkg_clean	This function is responsible for cleaning-up; notice
#			it is not called if one of the other functions
#			returns an error.
#
# Variables
#
#	PKG_ZIP		The name of the source package tar-zip file.
#
#	PKG_TAR		The name of the unzipped source package file.  This
#			file name will end in ".tar".
#
#	PKG_DIR		The name of the directory created by untarring the
#			${PKG_TAR} file.
#
#	PKG_STATUS	Set by the above function to indicate an error worthy
#			stopping the build process.
#
unset pkg_patch
unset pkg_configure
unset pkg_make
unset pkg_install
unset pkg_clean
source "${CROSSLINUX_PKGCFG_DIR}/$1/bld.sh"

# Get the source package, if any.  This function will unzip and untar the
# source package.
#
[[ "x${PKG_ZIP}" == "x(none)" ]] || CL_package_get ${PKG_ZIP}

# Prepare to create a list of the installed files.
#
rm --force INSTALL_STAMP
rm --force FILES
>INSTALL_STAMP
>FILES
sleep 1 # For detecting files newer than INSTALL_STAMP

# Figure the number of parallel jobs to give to make.
#
_bitch=${K_NCPU:-1}
[[ -z "${_bitch//[0-9]}" ]] && NJOBS=$((${_bitch:-1} + 1)) || NJOBS=2
unset _bitch
[[ x"${CONFIG_PARALLEL_JOBS:-}" == x"y" ]] || NJOBS=1

# Patch, configure, build, install and clean.
#
PKG_STATUS=""
echo -n "b." >&${CONSOLE_FD}
[[ -z "${PKG_STATUS}" ]] && pkg_patch     $1
[[ -z "${PKG_STATUS}" ]] && pkg_configure $1
[[ -z "${PKG_STATUS}" ]] && pkg_make      $1
[[ -z "${PKG_STATUS}" ]] && pkg_install   $1
[[ -z "${PKG_STATUS}" ]] && pkg_clean     $1
unset NJOBS
if [[ -n "${PKG_STATUS}" ]]; then
	CL_logcom "ERROR ***** ${PKG_STATUS}"
	echo -e "${TEXT_BRED}ERROR${TEXT_NORM}" >&${CONSOLE_FD}
	echo    "E> ${PKG_STATUS}"              >&${CONSOLE_FD}
	exit 1 # Bust out of sub-shell.
fi
unset PKG_STATUS

# Only the latest revision of libtool understands sysroot, but even it has
# problems when cross-building: remove the .la files.
#
rm --force ${TARGET_SYSROOT_DIR}/lib/*.la
rm --force ${TARGET_SYSROOT_DIR}/usr/lib/*.la

# Remove the un-tarred source package directory.
#
[[ -d "${PKG_DIR}" ]] && rm --force --recursive "${PKG_DIR}" || true
[[ -d "rootfs"     ]] && rm --force --recursive "rootfs"     || true

# Make a list of the installed files.  Remove sysroot and its path component
# from the file names.
#
echo -n "f." >&${CONSOLE_FD}
${cl_find} ${TARGET_SYSROOT_DIR} -newer INSTALL_STAMP | sort >> FILES
${cl_sed} --in-place "FILES" --expression="\#^${TARGET_SYSROOT_DIR}\$#d"
${cl_sed} --in-place "FILES" --expression="s|^${TARGET_SYSROOT_DIR}/||"
rm --force INSTALL_STAMP # All done with the INSTALL_STAMP file.

## Strip when possible.
##
#XBT_STRIP="${TTYLINUX_XTOOL_DIR}/host/usr/bin/${TTYLINUX_XBT}-strip"
#_bname=""
#if [[ x"${CONFIG_STRIP_BINS:-}" == x"y" ]]; then
#	CL_logcom "***** stripping"
#	for f in $(<FILES); do
#		[[ -d "${TTYLINUX_SYSROOT_DIR}/${f}" ]] && continue || true
#		if [[ "$(dirname ${f})" == "bin" ]]; then
#			echo "stripping ${f}"
#			"${XBT_STRIP}" "${TTYLINUX_SYSROOT_DIR}/${f}" || true
#		fi
#		if [[ "$(dirname ${f})" == "sbin" ]]; then
#			echo "stripping ${f}"
#			"${XBT_STRIP}" "${TTYLINUX_SYSROOT_DIR}/${f}" || true
#		fi
#		if [[ "$(dirname ${f})" == "usr/bin" ]]; then
#			echo "stripping ${f}"
#			"${XBT_STRIP}" "${TTYLINUX_SYSROOT_DIR}/${f}" || true
#		fi
#		if [[ "$(dirname ${f})" == "usr/sbin" ]]; then
#			echo "stripping ${f}"
#			"${XBT_STRIP}" "${TTYLINUX_SYSROOT_DIR}/${f}" || true
#		fi
#_bname="$(basename ${f})"
#[[ $(expr "${_bname}" : ".*\\(.o\)$" ) == ".o" ]] && continue || true
#[[ $(expr "${_bname}" : ".*\\(.a\)$" ) == ".a" ]] && continue || true
#		if [[ "$(dirname ${f})" == "lib" ]]; then
#			echo "stripping ${f}"
#			"${XBT_STRIP}" "${TTYLINUX_SYSROOT_DIR}/${f}" || true
#		fi
#[[ "${_bname}" == "libgcc_s.so"	  ]] && continue || true
#[[ "${_bname}" == "libgcc_s.so.1" ]] && continue || true
#		if [[ "$(dirname ${f})" == "usr/lib" ]]; then
#			echo "stripping ${f}"
#			"${XBT_STRIP}" "${TTYLINUX_SYSROOT_DIR}/${f}" || true
#		fi
#	done
#else
#	CL_logcom "***** not stripping"
#fi
#unset _bname

}


# *****************************************************************************
# Find the installed man pages, compress them, and adjust the file name in the
# so called database FILES list.
# *****************************************************************************

manpage_compress() {
:
}


# *****************************************************************************
# Collect the installed files into an as-built package.
# *****************************************************************************

package_collect() {

echo -n "p." >&${CONSOLE_FD}

local fileList=""
local shareDir="${TARGET_SYSROOT_DIR}/usr/share/${CONFIG_BRAND_NAME}"

# Save the list of files actually installed into sysroot/
#
cp --force FILES "${shareDir}/pkg-$1-FILES"
rm --force FILES # All done with the FILES file.

# Look for a package configuration file list.  There does not need to be one.
#
_fname1="${CROSSLINUX_PKGCFG_DIR}/$1/files"
_fname2="site/pkg-cfg-$1/files"
if [[ -f "${_fname1}" ]]; then
	fileList="${_fname1}"
fi
if [[ -f "${_fname1}-${CONFIG_CPU_ARCH}" ]]; then
	fileList="${_fname1}-${CONFIG_CPU_ARCH}"
fi
if [[ -f "${_fname2}" ]]; then
	fileList="${_fname2}"
fi
if [[ -f "${_fname2}-${CONFIG_CPU_ARCH}" ]]; then
	fileList="${_fname2}-${CONFIG_CPU_ARCH}"
fi
unset _fname1
unset _fname2

if [[ -z "${fileList}" ]]; then
	CL_logcom "ERROR ***** No file list for package $1."
	echo -e "${TEXT_BRED}ERROR${TEXT_NORM}"  >&${CONSOLE_FD}
	echo "E> No file list for package $1."   >&${CONSOLE_FD}
	exit 1
fi

# This is tricky.  First make a ${TARGET_VAR_DIR}/files from ${fileList}; then
# make a binary package from the list in ${TARGET_VAR_DIR}/files
#
package_list_make "${fileList}" || exit 1 # Bust out of sub-shell.
_uTarBall="${TARGET_PKGBIN_DIR}/$1-${CONFIG_CPU_ARCH}.tar"
_cTarBall="${TARGET_PKGBIN_DIR}/$1-${CONFIG_CPU_ARCH}.tbz"
${cl_tar} --create \
	--directory="${TARGET_SYSROOT_DIR}" \
	--file="${_uTarBall}" \
	--files-from="${TARGET_VAR_DIR}/files" \
	--no-recursion
${cl_bzip2} --force "${_uTarBall}"
mv --force "${_uTarBall}.bz2" "${_cTarBall}"
unset _uTarBall
unset _cTarBall
rm --force "${TARGET_VAR_DIR}/files" # Remove the temporary file.

echo -n "c" >&${CONSOLE_FD}

return 0

}


# *************************************************************************** #
#                                                                             #
# M A I N   P R O G R A M                                                     #
#                                                                             #
# *************************************************************************** #


# *****************************************************************************
# Set up the shell functions and environment variables.
# *****************************************************************************

declare -a K_PACKAGE=("") # Make an indexed array.

K_PKGLIST="crosslinux-pkglst.txt"
K_ZIPP="" # This is a mechanism to skip already-built packages.

source ./crosslinux-config.sh # target build configuration
source ${cl_libdir}/scripts/_constants.sh # build support
source ${cl_libdir}/scripts/_functions.sh # build support

CL_config_setup || exit 1


# *****************************************************************************
# Main Program
# *****************************************************************************

# Check for a script argument:
#
# $1 == "continue" ... This is a continuation flag, start making packages after
#                      the last one previously made.
#
# $1 == <name> ....... Anything other than "continue" is interpreted as a
#                      package name, so build the one named package.

if [[ $# -gt 0 && -n "$1" ]]; then
	# "$1" may be unbound so hide it in this if statement.
	# Set the K_ZIPP flag, if so given; otherwise reset the package list.
	[[ "$1" == "continue" ]] && K_ZIPP="y" || K_PACKAGE=("$1")
fi

_c=0 # Package count.
_p=${K_PACKAGE[${_c}]}

if [[ -z "${K_PACKAGE[0]}" ]]; then
	# Need to get the list of packages from the ${K_PKGLIST} file.
	while read pname pad; do
		[[ -z "${pname}"                       ]] && continue || true
		[[ "${pname:0:1}" == "#"               ]] && continue || true
		[[ -n "${_p}" && "${pname}" != "${_p}" ]] && continue || true
		K_PACKAGE[${_c}]=${pname}
		_c=$((${_c} + 1))
	done <${K_PKGLIST}
fi

if [[ ${_c} -eq 0 && -n "${_p}" ]]; then
	echo "E> No package named \"${_p}\""
	exit 1
fi

unset _c
unset _p

if [[ -z "${K_PACKAGE}" ]]; then
	echo "E> No packages to build.  How did you do that?"
	exit 1
fi

# -----------------------------------------------------------------------------
# Build Package(s)
# -----------------------------------------------------------------------------

echo ""
echo "##### START cross-building packages"
echo "g - getting the source and configuration packages"
echo "b - building and installing the package into sysroot"
echo "f - finding installed files"
echo "m - looking for man pages to compress"
echo "p - creating installable package"
echo "c - cleaning"
echo ""

pushd "${TARGET_BUILD_DIR}/packages" >/dev/null 2>&1

if [[ $(ls -1 | wc -l) -ne 0 ]]; then
	echo "w> build/packages build directory is not empty:"
	ls -l
	echo ""
fi

T1P=${SECONDS}

for p in ${K_PACKAGE[@]}; do

	[[ -n "${K_ZIPP}" && -f "${TARGET_VAR_DIR}/run/done.${p}" ]] && continue

	if [[ ! -d "${CROSSLINUX_PKGCFG_DIR}/${p}" ]]; then
		echo -e "E> No ${TEXT_RED}pkg-cfg/${p}${TEXT_NORM} directory."
		echo    "=> crosslinux does not support building '${p}'"
		exit 1
	fi

	t1=${SECONDS}

	echo -n "${p} ";
	for ((i=(30-${#p}) ; i > 0 ; i--)); do echo -n "."; done
	echo -n " ";

	exec 4>&1    # Save stdout at fd 4.
	CONSOLE_FD=4 #

	# Even with 'set +e' the trap handler will run if a command or shell
	# function returns non-zero, and in that case the trap handler also
	# will run when the subshell completes.  Set 'CL_exitOnSigErr' to zero
	# to not let the trap handler exit the shell when the subsell returns
	# an error so the return value can be checked and a message printed
	# before exiting the shell; also don't print the backtrace info because
        # it did that in the subshell.
	#
	set +e ; # Let a build step fail without exiting this script.
	CL_infoOnSigErr=0
	CL_exitOnSigErr=0
	(
	# The subshell's 'CL_infoOnSigErr' needs to be set so the trap handler
	# will print a backtrace for the subshell, if a command or shell
	# function returns non-zero.
	CL_infoOnSigErr=1
	rm --force "${TARGET_VAR_DIR}/log/${p}.log"
	package_xbuild  "${p}" >>"${TARGET_VAR_DIR}/log/${p}.log" 2>&1
	manpage_compress       >>"${TARGET_VAR_DIR}/log/${p}.log" 2>&1
	package_collect "${p}" >>"${TARGET_VAR_DIR}/log/${p}.log" 2>&1
	)
	if [[ $? -ne 0 ]]; then
		echo -e "${TEXT_BRED}ERROR${TEXT_NORM}"
		echo "Check the build log files.  Probably check:"
		echo "=> ${TARGET_VAR_DIR}/log/${p}.log"
		exit 1
	fi
	set -e ; # All done with build steps; enable exit on a non-zero status.
	CL_infoOnSigErr=1
	CL_exitOnSigErr=1

	exec >&4     # Set fd 1 back to stdout.
	CONSOLE_FD=1 #

	>"${TARGET_VAR_DIR}/run/done.${p}"

	echo -n " ... DONE ["
	t2=${SECONDS}
	mins=$(((${t2}-${t1})/60))
	secs=$(((${t2}-${t1})%60))
	[[ ${#mins} -eq 1 ]] && echo -n " "; echo -n "${mins} minutes "
	[[ ${#secs} -eq 1 ]] && echo -n " "; echo -n "${secs} seconds"
	echo "]"

	if [[ $(ls -1 | wc -l) -ne 0 ]]; then
		echo "w> build/packages build directory is not empty:"
		ls -l
	fi

done; unset p

T2P=${SECONDS}
echo "=> $(((${T2P}-${T1P})/60)) minutes $(((${T2P}-${T1P})%60)) seconds"
echo ""

popd >/dev/null 2>&1

echo "##### DONE cross-building packages"


# *****************************************************************************
# Exit with Status
# *****************************************************************************

exit 0


# end of file
